{"ast":null,"code":"import { jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useMemo } from \"react\";\nimport { Uniform, Texture, Color, CanvasTexture, RepeatWrapping, NearestFilter } from \"three\";\nimport { Effect } from \"postprocessing\";\nconst fragment = \"\\nuniform sampler2D uCharacters;\\nuniform float uCharactersCount;\\nuniform float uCellSize;\\nuniform bool uInvert;\\nuniform vec3 uColor;\\n\\nconst vec2 SIZE = vec2(16.);\\n\\nvec3 greyscale(vec3 color, float strength) {\\n    float g = dot(color, vec3(0.299, 0.587, 0.114));\\n    return mix(color, vec3(g), strength);\\n}\\n\\nvec3 greyscale(vec3 color) {\\n    return greyscale(color, 1.0);\\n}\\n\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\n    vec2 cell = resolution / uCellSize;\\n    vec2 grid = 1.0 / cell;\\n    vec2 pixelizedUV = grid * (0.5 + floor(uv / grid));\\n    vec4 pixelized = texture2D(inputBuffer, pixelizedUV);\\n    float greyscaled = greyscale(pixelized.rgb).r;\\n\\n    if (uInvert) {\\n        greyscaled = 1.0 - greyscaled;\\n    }\\n\\n    float characterIndex = floor((uCharactersCount - 1.0) * greyscaled);\\n    vec2 characterPosition = vec2(mod(characterIndex, SIZE.x), floor(characterIndex / SIZE.y));\\n    vec2 offset = vec2(characterPosition.x, -characterPosition.y) / SIZE;\\n    vec2 charUV = mod(uv * (cell / SIZE), 1.0 / SIZE) - vec2(0., 1.0 / SIZE) + offset;\\n    vec4 asciiCharacter = texture2D(uCharacters, charUV);\\n\\n    asciiCharacter.rgb = uColor * asciiCharacter.r;\\n    asciiCharacter.a = pixelized.a;\\n    outputColor = asciiCharacter;\\n}\\n\";\nclass ASCIIEffect extends Effect {\n  constructor() {\n    let {\n      font = \"arial\",\n      characters = \" .:,'-^=*+?!|0#X%WM@\",\n      fontSize = 54,\n      cellSize = 16,\n      color = \"#ffffff\",\n      invert = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const uniforms = /* @__PURE__ */new Map([[\"uCharacters\", new Uniform(new Texture())], [\"uCellSize\", new Uniform(cellSize)], [\"uCharactersCount\", new Uniform(characters.length)], [\"uColor\", new Uniform(new Color(color))], [\"uInvert\", new Uniform(invert)]]);\n    super(\"ASCIIEffect\", fragment, {\n      uniforms\n    });\n    const charactersTextureUniform = this.uniforms.get(\"uCharacters\");\n    if (charactersTextureUniform) {\n      charactersTextureUniform.value = this.createCharactersTexture(characters, font, fontSize);\n    }\n  }\n  /** Draws the characters on a Canvas and returns a texture */\n  createCharactersTexture(characters, font, fontSize) {\n    const canvas = document.createElement(\"canvas\");\n    const SIZE = 1024;\n    const MAX_PER_ROW = 16;\n    const CELL = SIZE / MAX_PER_ROW;\n    canvas.width = canvas.height = SIZE;\n    const texture = new CanvasTexture(canvas, void 0, RepeatWrapping, RepeatWrapping, NearestFilter, NearestFilter);\n    const context = canvas.getContext(\"2d\");\n    if (!context) {\n      throw new Error(\"Context not available\");\n    }\n    context.clearRect(0, 0, SIZE, SIZE);\n    context.font = \"\".concat(fontSize, \"px \").concat(font);\n    context.textAlign = \"center\";\n    context.textBaseline = \"middle\";\n    context.fillStyle = \"#fff\";\n    for (let i = 0; i < characters.length; i++) {\n      const char = characters[i];\n      const x = i % MAX_PER_ROW;\n      const y = Math.floor(i / MAX_PER_ROW);\n      context.fillText(char, x * CELL + CELL / 2, y * CELL + CELL / 2);\n    }\n    texture.needsUpdate = true;\n    return texture;\n  }\n}\nconst ASCII = forwardRef((_ref, fref) => {\n  let {\n    font = \"arial\",\n    characters = \" .:,'-^=*+?!|0#X%WM@\",\n    fontSize = 54,\n    cellSize = 16,\n    color = \"#ffffff\",\n    invert = false\n  } = _ref;\n  const effect = useMemo(() => new ASCIIEffect({\n    characters,\n    font,\n    fontSize,\n    cellSize,\n    color,\n    invert\n  }), [characters, fontSize, cellSize, color, invert, font]);\n  return /* @__PURE__ */jsx(\"primitive\", {\n    ref: fref,\n    object: effect\n  });\n});\nexport { ASCII };","map":{"version":3,"names":["fragment","ASCIIEffect","Effect","constructor","font","characters","fontSize","cellSize","color","invert","arguments","length","undefined","uniforms","Map","Uniform","Texture","Color","charactersTextureUniform","get","value","createCharactersTexture","canvas","document","createElement","SIZE","MAX_PER_ROW","CELL","width","height","texture","CanvasTexture","RepeatWrapping","NearestFilter","context","getContext","Error","clearRect","concat","textAlign","textBaseline","fillStyle","i","char","x","y","Math","floor","fillText","needsUpdate","ASCII","forwardRef","_ref","fref","effect","useMemo","jsx","ref","object"],"sources":["C:\\Users\\Catriel\\Desktop\\3d-react\\node_modules\\@react-three\\postprocessing\\src\\effects\\ASCII.tsx"],"sourcesContent":["// From: https://github.com/emilwidlund/ASCII\n// https://twitter.com/emilwidlund/status/1652386482420609024\n\nimport { forwardRef, useMemo } from 'react'\nimport { CanvasTexture, Color, NearestFilter, RepeatWrapping, Texture, Uniform } from 'three'\nimport { Effect } from 'postprocessing'\n\nconst fragment = `\nuniform sampler2D uCharacters;\nuniform float uCharactersCount;\nuniform float uCellSize;\nuniform bool uInvert;\nuniform vec3 uColor;\n\nconst vec2 SIZE = vec2(16.);\n\nvec3 greyscale(vec3 color, float strength) {\n    float g = dot(color, vec3(0.299, 0.587, 0.114));\n    return mix(color, vec3(g), strength);\n}\n\nvec3 greyscale(vec3 color) {\n    return greyscale(color, 1.0);\n}\n\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n    vec2 cell = resolution / uCellSize;\n    vec2 grid = 1.0 / cell;\n    vec2 pixelizedUV = grid * (0.5 + floor(uv / grid));\n    vec4 pixelized = texture2D(inputBuffer, pixelizedUV);\n    float greyscaled = greyscale(pixelized.rgb).r;\n\n    if (uInvert) {\n        greyscaled = 1.0 - greyscaled;\n    }\n\n    float characterIndex = floor((uCharactersCount - 1.0) * greyscaled);\n    vec2 characterPosition = vec2(mod(characterIndex, SIZE.x), floor(characterIndex / SIZE.y));\n    vec2 offset = vec2(characterPosition.x, -characterPosition.y) / SIZE;\n    vec2 charUV = mod(uv * (cell / SIZE), 1.0 / SIZE) - vec2(0., 1.0 / SIZE) + offset;\n    vec4 asciiCharacter = texture2D(uCharacters, charUV);\n\n    asciiCharacter.rgb = uColor * asciiCharacter.r;\n    asciiCharacter.a = pixelized.a;\n    outputColor = asciiCharacter;\n}\n`\n\ninterface IASCIIEffectProps {\n  font?: string\n  characters?: string\n  fontSize?: number\n  cellSize?: number\n  color?: string\n  invert?: boolean\n}\n\nclass ASCIIEffect extends Effect {\n  constructor({\n    font = 'arial',\n    characters = ` .:,'-^=*+?!|0#X%WM@`,\n    fontSize = 54,\n    cellSize = 16,\n    color = '#ffffff',\n    invert = false,\n  }: IASCIIEffectProps = {}) {\n    const uniforms = new Map<string, Uniform>([\n      ['uCharacters', new Uniform(new Texture())],\n      ['uCellSize', new Uniform(cellSize)],\n      ['uCharactersCount', new Uniform(characters.length)],\n      ['uColor', new Uniform(new Color(color))],\n      ['uInvert', new Uniform(invert)],\n    ])\n\n    super('ASCIIEffect', fragment, { uniforms })\n\n    const charactersTextureUniform = this.uniforms.get('uCharacters')\n\n    if (charactersTextureUniform) {\n      charactersTextureUniform.value = this.createCharactersTexture(characters, font, fontSize)\n    }\n  }\n\n  /** Draws the characters on a Canvas and returns a texture */\n  public createCharactersTexture(characters: string, font: string, fontSize: number): THREE.Texture {\n    const canvas = document.createElement('canvas')\n    const SIZE = 1024\n    const MAX_PER_ROW = 16\n    const CELL = SIZE / MAX_PER_ROW\n\n    canvas.width = canvas.height = SIZE\n    const texture = new CanvasTexture(canvas, undefined, RepeatWrapping, RepeatWrapping, NearestFilter, NearestFilter)\n    const context = canvas.getContext('2d')\n\n    if (!context) {\n      throw new Error('Context not available')\n    }\n\n    context.clearRect(0, 0, SIZE, SIZE)\n    context.font = `${fontSize}px ${font}`\n    context.textAlign = 'center'\n    context.textBaseline = 'middle'\n    context.fillStyle = '#fff'\n\n    for (let i = 0; i < characters.length; i++) {\n      const char = characters[i]\n      const x = i % MAX_PER_ROW\n      const y = Math.floor(i / MAX_PER_ROW)\n      context.fillText(char, x * CELL + CELL / 2, y * CELL + CELL / 2)\n    }\n\n    texture.needsUpdate = true\n    return texture\n  }\n}\n\nexport const ASCII = forwardRef<ASCIIEffect, IASCIIEffectProps>(\n  (\n    {\n      font = 'arial',\n      characters = ` .:,'-^=*+?!|0#X%WM@`,\n      fontSize = 54,\n      cellSize = 16,\n      color = '#ffffff',\n      invert = false,\n    },\n    fref\n  ) => {\n    const effect = useMemo(\n      () => new ASCIIEffect({ characters, font, fontSize, cellSize, color, invert }),\n      [characters, fontSize, cellSize, color, invert, font]\n    )\n    return <primitive ref={fref} object={effect} />\n  }\n)\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}