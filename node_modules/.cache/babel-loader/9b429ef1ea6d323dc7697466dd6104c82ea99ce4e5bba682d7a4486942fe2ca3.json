{"ast":null,"code":"import { jsx } from \"react/jsx-runtime\";\nimport { OutlineEffect } from \"postprocessing\";\nimport { forwardRef, useContext, useMemo, useEffect, useRef } from \"react\";\nimport { useThree } from \"@react-three/fiber\";\nimport { EffectComposerContext } from \"../EffectComposer.js\";\nimport { selectionContext } from \"../Selection.js\";\nimport { resolveRef } from \"../util.js\";\nconst Outline = forwardRef(function Outline2(_ref, forwardRef2) {\n  let {\n    selection = [],\n    selectionLayer = 10,\n    blendFunction,\n    patternTexture,\n    edgeStrength,\n    pulseSpeed,\n    visibleEdgeColor,\n    hiddenEdgeColor,\n    width,\n    height,\n    kernelSize,\n    blur,\n    xRay,\n    ...props\n  } = _ref;\n  const invalidate = useThree(state => state.invalidate);\n  const {\n    scene,\n    camera\n  } = useContext(EffectComposerContext);\n  const effect = useMemo(() => new OutlineEffect(scene, camera, {\n    blendFunction,\n    patternTexture,\n    edgeStrength,\n    pulseSpeed,\n    visibleEdgeColor,\n    hiddenEdgeColor,\n    width,\n    height,\n    kernelSize,\n    blur,\n    xRay,\n    ...props\n  }), [blendFunction, blur, camera, edgeStrength, height, hiddenEdgeColor, kernelSize, patternTexture, pulseSpeed, scene, visibleEdgeColor, width, xRay]);\n  const api = useContext(selectionContext);\n  useEffect(() => {\n    if (!api && selection) {\n      effect.selection.set(Array.isArray(selection) ? selection.map(resolveRef) : [resolveRef(selection)]);\n      invalidate();\n      return () => {\n        effect.selection.clear();\n        invalidate();\n      };\n    }\n  }, [effect, selection, api, invalidate]);\n  useEffect(() => {\n    effect.selectionLayer = selectionLayer;\n    invalidate();\n  }, [effect, invalidate, selectionLayer]);\n  useRef();\n  useEffect(() => {\n    var _a;\n    if (api && api.enabled) {\n      if ((_a = api.selected) == null ? void 0 : _a.length) {\n        effect.selection.set(api.selected);\n        invalidate();\n        return () => {\n          effect.selection.clear();\n          invalidate();\n        };\n      }\n    }\n  }, [api, effect.selection, invalidate]);\n  useEffect(() => {\n    return () => {\n      effect.dispose();\n    };\n  }, [effect]);\n  return /* @__PURE__ */jsx(\"primitive\", {\n    ref: forwardRef2,\n    object: effect\n  });\n});\nexport { Outline };","map":{"version":3,"names":["Outline","forwardRef","Outline2","_ref","forwardRef2","selection","selectionLayer","blendFunction","patternTexture","edgeStrength","pulseSpeed","visibleEdgeColor","hiddenEdgeColor","width","height","kernelSize","blur","xRay","props","invalidate","useThree","state","scene","camera","useContext","EffectComposerContext","effect","useMemo","OutlineEffect","api","selectionContext","useEffect","set","Array","isArray","map","resolveRef","clear","useRef","enabled","_a","selected","length","dispose","jsx","ref","object"],"sources":["C:\\Users\\Catriel\\Desktop\\3d-react\\node_modules\\@react-three\\postprocessing\\src\\effects\\Outline.tsx"],"sourcesContent":["import { OutlineEffect } from 'postprocessing'\nimport { Ref, MutableRefObject, forwardRef, useMemo, useEffect, useContext, useRef } from 'react'\nimport { Object3D } from 'three'\nimport { useThree } from '@react-three/fiber'\nimport { EffectComposerContext } from '../EffectComposer'\nimport { selectionContext } from '../Selection'\nimport { resolveRef } from '../util'\n\ntype ObjectRef = MutableRefObject<Object3D>\n\nexport type OutlineProps = ConstructorParameters<typeof OutlineEffect>[2] &\n  Partial<{\n    selection: Object3D | Object3D[] | ObjectRef | ObjectRef[]\n    selectionLayer: number\n  }>\n\nexport const Outline = forwardRef(function Outline(\n  {\n    selection = [],\n    selectionLayer = 10,\n    blendFunction,\n    patternTexture,\n    edgeStrength,\n    pulseSpeed,\n    visibleEdgeColor,\n    hiddenEdgeColor,\n    width,\n    height,\n    kernelSize,\n    blur,\n    xRay,\n    ...props\n  }: OutlineProps,\n  forwardRef: Ref<OutlineEffect>\n) {\n  const invalidate = useThree((state) => state.invalidate)\n  const { scene, camera } = useContext(EffectComposerContext)\n\n  const effect = useMemo(\n    () =>\n      new OutlineEffect(scene, camera, {\n        blendFunction,\n        patternTexture,\n        edgeStrength,\n        pulseSpeed,\n        visibleEdgeColor,\n        hiddenEdgeColor,\n        width,\n        height,\n        kernelSize,\n        blur,\n        xRay,\n        ...props,\n      }),\n    [\n      blendFunction,\n      blur,\n      camera,\n      edgeStrength,\n      height,\n      hiddenEdgeColor,\n      kernelSize,\n      patternTexture,\n      pulseSpeed,\n      scene,\n      visibleEdgeColor,\n      width,\n      xRay,\n    ]\n  )\n\n  const api = useContext(selectionContext)\n\n  useEffect(() => {\n    // Do not allow array selection if declarative selection is active\n    // TODO: array selection should probably be deprecated altogether\n    if (!api && selection) {\n      effect.selection.set(\n        Array.isArray(selection) ? (selection as Object3D[]).map(resolveRef) : [resolveRef(selection) as Object3D]\n      )\n      invalidate()\n      return () => {\n        effect.selection.clear()\n        invalidate()\n      }\n    }\n  }, [effect, selection, api, invalidate])\n\n  useEffect(() => {\n    effect.selectionLayer = selectionLayer\n    invalidate()\n  }, [effect, invalidate, selectionLayer])\n\n  const ref = useRef<OutlineEffect>()\n  useEffect(() => {\n    if (api && api.enabled) {\n      if (api.selected?.length) {\n        effect.selection.set(api.selected)\n        invalidate()\n        return () => {\n          effect.selection.clear()\n          invalidate()\n        }\n      }\n    }\n  }, [api, effect.selection, invalidate])\n\n  useEffect(() => {\n    return () => {\n      effect.dispose()\n    }\n  }, [effect])\n\n  return <primitive ref={forwardRef} object={effect} />\n})\n"],"mappings":";;;;;;;AAgBa,MAAAA,OAAA,GAAUC,UAAA,CAAW,SAASC,SAAAC,IAAA,EAiBzCC,WAAA,EACA;EAAA,IAjBA;IACEC,SAAA,GAAY,EAAC;IACbC,cAAA,GAAiB;IACjBC,aAAA;IACAC,cAAA;IACAC,YAAA;IACAC,UAAA;IACAC,gBAAA;IACAC,eAAA;IACAC,KAAA;IACAC,MAAA;IACAC,UAAA;IACAC,IAAA;IACAC,IAAA;IACA,GAAGC;EACL,IAAAf,IAAA;EAGA,MAAMgB,UAAA,GAAaC,QAAA,CAAUC,KAAA,IAAUA,KAAA,CAAMF,UAAU;EACvD,MAAM;IAAEG,KAAA;IAAOC;EAAO,IAAIC,UAAA,CAAWC,qBAAqB;EAE1D,MAAMC,MAAA,GAASC,OAAA,CACb,MACE,IAAIC,aAAA,CAAcN,KAAA,EAAOC,MAAA,EAAQ;IAC/BhB,aAAA;IACAC,cAAA;IACAC,YAAA;IACAC,UAAA;IACAC,gBAAA;IACAC,eAAA;IACAC,KAAA;IACAC,MAAA;IACAC,UAAA;IACAC,IAAA;IACAC,IAAA;IACA,GAAGC;EAAA,CACJ,GACH,CACEX,aAAA,EACAS,IAAA,EACAO,MAAA,EACAd,YAAA,EACAK,MAAA,EACAF,eAAA,EACAG,UAAA,EACAP,cAAA,EACAE,UAAA,EACAY,KAAA,EACAX,gBAAA,EACAE,KAAA,EACAI,IAAA,CACF;EAGI,MAAAY,GAAA,GAAML,UAAA,CAAWM,gBAAgB;EAEvCC,SAAA,CAAU,MAAM;IAGV,KAACF,GAAA,IAAOxB,SAAA,EAAW;MACrBqB,MAAA,CAAOrB,SAAA,CAAU2B,GAAA,CACfC,KAAA,CAAMC,OAAA,CAAQ7B,SAAS,IAAKA,SAAA,CAAyB8B,GAAA,CAAIC,UAAU,IAAI,CAACA,UAAA,CAAW/B,SAAS,CAAa;MAEhGc,UAAA;MACX,OAAO,MAAM;QACXO,MAAA,CAAOrB,SAAA,CAAUgC,KAAA;QACNlB,UAAA;MAAA;IAEf;EAAA,GACC,CAACO,MAAA,EAAQrB,SAAA,EAAWwB,GAAA,EAAKV,UAAU,CAAC;EAEvCY,SAAA,CAAU,MAAM;IACdL,MAAA,CAAOpB,cAAA,GAAiBA,cAAA;IACba,UAAA;EACV,IAACO,MAAA,EAAQP,UAAA,EAAYb,cAAc,CAAC;EAE3BgC,MAAA,CAAsB;EAClCP,SAAA,CAAU,MAAM;;IACV,IAAAF,GAAA,IAAOA,GAAA,CAAIU,OAAA,EAAS;MAClB,KAAAC,EAAA,GAAAX,GAAA,CAAIY,QAAA,KAAJ,gBAAAD,EAAA,CAAcE,MAAA,EAAQ;QACjBhB,MAAA,CAAArB,SAAA,CAAU2B,GAAA,CAAIH,GAAA,CAAIY,QAAQ;QACtBtB,UAAA;QACX,OAAO,MAAM;UACXO,MAAA,CAAOrB,SAAA,CAAUgC,KAAA;UACNlB,UAAA;QAAA;MAEf;IACF;EAAA,GACC,CAACU,GAAA,EAAKH,MAAA,CAAOrB,SAAA,EAAWc,UAAU,CAAC;EAEtCY,SAAA,CAAU,MAAM;IACd,OAAO,MAAM;MACXL,MAAA,CAAOiB,OAAA,CAAQ;IAAA;EACjB,GACC,CAACjB,MAAM,CAAC;EAEX,OAAQ,eAAAkB,GAAA;IAAUC,GAAA,EAAKzC,WAAA;IAAY0C,MAAA,EAAQpB;EAAQ;AACrD,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}