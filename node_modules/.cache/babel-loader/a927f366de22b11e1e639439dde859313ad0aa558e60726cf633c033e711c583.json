{"ast":null,"code":"import { jsxs, Fragment, jsx } from \"react/jsx-runtime\";\nimport * as THREE from \"three\";\nimport { forwardRef, useRef, useContext, useState, useEffect, useCallback, useMemo, useImperativeHandle } from \"react\";\nimport { useThree, useFrame, createPortal } from \"@react-three/fiber\";\nimport { DepthPickingPass, CopyPass } from \"postprocessing\";\nimport { easing } from \"maath\";\nimport { DepthOfField } from \"./DepthOfField.js\";\nimport { EffectComposerContext } from \"../EffectComposer.js\";\nconst Autofocus = forwardRef((_ref, fref) => {\n  let {\n    target = void 0,\n    mouse: followMouse = false,\n    debug = void 0,\n    manual = false,\n    smoothTime = 0.25,\n    ...props\n  } = _ref;\n  const dofRef = useRef(null);\n  const hitpointRef = useRef(null);\n  const targetRef = useRef(null);\n  const scene = useThree(_ref2 => {\n    let {\n      scene: scene2\n    } = _ref2;\n    return scene2;\n  });\n  const pointer = useThree(_ref3 => {\n    let {\n      pointer: pointer2\n    } = _ref3;\n    return pointer2;\n  });\n  const {\n    composer,\n    camera\n  } = useContext(EffectComposerContext);\n  const [depthPickingPass] = useState(() => new DepthPickingPass());\n  const [copyPass] = useState(() => new CopyPass());\n  useEffect(() => {\n    composer.addPass(depthPickingPass);\n    composer.addPass(copyPass);\n    return () => {\n      composer.removePass(depthPickingPass);\n      composer.removePass(copyPass);\n    };\n  }, [composer, depthPickingPass, copyPass]);\n  useEffect(() => {\n    return () => {\n      depthPickingPass.dispose();\n      copyPass.dispose();\n    };\n  }, [depthPickingPass, copyPass]);\n  const [hitpoint] = useState(() => new THREE.Vector3(0, 0, 0));\n  const [ndc] = useState(() => new THREE.Vector3(0, 0, 0));\n  const getHit = useCallback(async (x, y) => {\n    ndc.x = x;\n    ndc.y = y;\n    ndc.z = await depthPickingPass.readDepth(ndc);\n    ndc.z = ndc.z * 2 - 1;\n    const hit = 1 - ndc.z > 1e-7;\n    return hit ? ndc.unproject(camera) : false;\n  }, [ndc, depthPickingPass, camera]);\n  const update = useCallback(async function (delta) {\n    let updateTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var _a;\n    if (target) {\n      hitpoint.set(...target);\n    } else {\n      const {\n        x,\n        y\n      } = followMouse ? pointer : {\n        x: 0,\n        y: 0\n      };\n      const hit = await getHit(x, y);\n      if (hit) hitpoint.copy(hit);\n    }\n    if (updateTarget && ((_a = dofRef.current) == null ? void 0 : _a.target)) {\n      if (smoothTime > 0 && delta > 0) {\n        easing.damp3(dofRef.current.target, hitpoint, smoothTime, delta);\n      } else {\n        dofRef.current.target.copy(hitpoint);\n      }\n    }\n  }, [target, hitpoint, followMouse, getHit, smoothTime, pointer]);\n  useFrame(async (_, delta) => {\n    var _a;\n    if (!manual) {\n      update(delta);\n    }\n    if (hitpointRef.current) {\n      hitpointRef.current.position.copy(hitpoint);\n    }\n    if (targetRef.current && ((_a = dofRef.current) == null ? void 0 : _a.target)) {\n      targetRef.current.position.copy(dofRef.current.target);\n    }\n  });\n  const api = useMemo(() => ({\n    dofRef,\n    hitpoint,\n    update\n  }), [hitpoint, update]);\n  useImperativeHandle(fref, () => api, [api]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [debug ? createPortal( /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsxs(\"mesh\", {\n        ref: hitpointRef,\n        children: [/* @__PURE__ */jsx(\"sphereGeometry\", {\n          args: [debug, 16, 16]\n        }), /* @__PURE__ */jsx(\"meshBasicMaterial\", {\n          color: \"#00ff00\",\n          opacity: 1,\n          transparent: true,\n          depthWrite: false\n        })]\n      }), /* @__PURE__ */jsxs(\"mesh\", {\n        ref: targetRef,\n        children: [/* @__PURE__ */jsx(\"sphereGeometry\", {\n          args: [debug / 2, 16, 16]\n        }), /* @__PURE__ */jsx(\"meshBasicMaterial\", {\n          color: \"#00ff00\",\n          opacity: 0.5,\n          transparent: true,\n          depthWrite: false\n        })]\n      })]\n    }), scene) : null, /* @__PURE__ */jsx(DepthOfField, {\n      ref: dofRef,\n      ...props,\n      target: hitpoint\n    })]\n  });\n});\nexport { Autofocus };","map":{"version":3,"names":["Autofocus","forwardRef","_ref","fref","target","mouse","followMouse","debug","manual","smoothTime","props","dofRef","useRef","hitpointRef","targetRef","scene","useThree","_ref2","scene2","pointer","_ref3","pointer2","composer","camera","useContext","EffectComposerContext","depthPickingPass","useState","DepthPickingPass","copyPass","CopyPass","useEffect","addPass","removePass","dispose","hitpoint","THREE","Vector3","ndc","getHit","useCallback","x","y","z","readDepth","hit","unproject","update","delta","updateTarget","arguments","length","undefined","set","copy","_a","current","easing","damp3","useFrame","_","position","api","useMemo","useImperativeHandle","jsxs","Fragment","children","createPortal","ref","jsx","args","color","opacity","transparent","depthWrite","DepthOfField"],"sources":["C:\\Users\\Catriel\\Desktop\\3d-react\\node_modules\\@react-three\\postprocessing\\src\\effects\\Autofocus.tsx"],"sourcesContent":["import * as THREE from 'three'\nimport React, {\n  useRef,\n  useContext,\n  useState,\n  useEffect,\n  useCallback,\n  forwardRef,\n  useImperativeHandle,\n  RefObject,\n  useMemo,\n} from 'react'\nimport { useThree, useFrame, createPortal, Vector3 } from '@react-three/fiber'\nimport { CopyPass, DepthPickingPass, DepthOfFieldEffect } from 'postprocessing'\nimport { easing } from 'maath'\n\nimport { DepthOfField } from './DepthOfField'\nimport { EffectComposerContext } from '../EffectComposer'\n\nexport type AutofocusProps = React.ComponentProps<typeof DepthOfField> & {\n  target?: Vector3\n  /** should the target follow the pointer */\n  mouse?: boolean\n  /** size of the debug green point  */\n  debug?: number\n  /** manual update */\n  manual?: boolean\n  /** approximate time to reach the target */\n  smoothTime?: number\n}\n\nexport type AutofocusApi = {\n  dofRef: RefObject<DepthOfFieldEffect>\n  hitpoint: THREE.Vector3\n  update: (delta: number, updateTarget: boolean) => void\n}\n\nexport const Autofocus = forwardRef<AutofocusApi, AutofocusProps>(\n  (\n    { target = undefined, mouse: followMouse = false, debug = undefined, manual = false, smoothTime = 0.25, ...props },\n    fref\n  ) => {\n    const dofRef = useRef<DepthOfFieldEffect>(null)\n    const hitpointRef = useRef<THREE.Mesh>(null)\n    const targetRef = useRef<THREE.Mesh>(null)\n\n    const scene = useThree(({ scene }) => scene)\n    const pointer = useThree(({ pointer }) => pointer)\n    const { composer, camera } = useContext(EffectComposerContext)\n\n    // see: https://codesandbox.io/s/depthpickingpass-x130hg\n    const [depthPickingPass] = useState(() => new DepthPickingPass())\n    const [copyPass] = useState(() => new CopyPass())\n    useEffect(() => {\n      composer.addPass(depthPickingPass)\n      composer.addPass(copyPass)\n      return () => {\n        composer.removePass(depthPickingPass)\n        composer.removePass(copyPass)\n      }\n    }, [composer, depthPickingPass, copyPass])\n\n    useEffect(() => {\n      return () => {\n        depthPickingPass.dispose()\n        copyPass.dispose()\n      }\n    }, [depthPickingPass, copyPass])\n\n    const [hitpoint] = useState(() => new THREE.Vector3(0, 0, 0))\n\n    const [ndc] = useState(() => new THREE.Vector3(0, 0, 0))\n    const getHit = useCallback(\n      async (x: number, y: number) => {\n        ndc.x = x\n        ndc.y = y\n        ndc.z = await depthPickingPass.readDepth(ndc)\n        ndc.z = ndc.z * 2.0 - 1.0\n        const hit = 1 - ndc.z > 0.0000001 // it is missed if ndc.z is close to 1\n        return hit ? ndc.unproject(camera) : false\n      },\n      [ndc, depthPickingPass, camera]\n    )\n\n    const update = useCallback(\n      async (delta: number, updateTarget = true) => {\n        // Update hitpoint\n        if (target) {\n          hitpoint.set(...(target as [number, number, number]))\n        } else {\n          const { x, y } = followMouse ? pointer : { x: 0, y: 0 }\n          const hit = await getHit(x, y)\n          if (hit) hitpoint.copy(hit)\n        }\n\n        // Update target\n        if (updateTarget && dofRef.current?.target) {\n          if (smoothTime > 0 && delta > 0) {\n            easing.damp3(dofRef.current.target, hitpoint, smoothTime, delta)\n          } else {\n            dofRef.current.target.copy(hitpoint)\n          }\n        }\n      },\n      [target, hitpoint, followMouse, getHit, smoothTime, pointer]\n    )\n\n    useFrame(async (_, delta) => {\n      if (!manual) {\n        update(delta)\n      }\n      if (hitpointRef.current) {\n        hitpointRef.current.position.copy(hitpoint)\n      }\n      if (targetRef.current && dofRef.current?.target) {\n        targetRef.current.position.copy(dofRef.current.target)\n      }\n    })\n\n    // Ref API\n    const api = useMemo<AutofocusApi>(\n      () => ({\n        dofRef,\n        hitpoint,\n        update,\n      }),\n      [hitpoint, update]\n    )\n    useImperativeHandle(fref, () => api, [api])\n\n    return (\n      <>\n        {debug\n          ? createPortal(\n              <>\n                <mesh ref={hitpointRef}>\n                  <sphereGeometry args={[debug, 16, 16]} />\n                  <meshBasicMaterial color=\"#00ff00\" opacity={1} transparent depthWrite={false} />\n                </mesh>\n                <mesh ref={targetRef}>\n                  <sphereGeometry args={[debug / 2, 16, 16]} />\n                  <meshBasicMaterial color=\"#00ff00\" opacity={0.5} transparent depthWrite={false} />\n                </mesh>\n              </>,\n              scene\n            )\n          : null}\n\n        <DepthOfField ref={dofRef} {...props} target={hitpoint} />\n      </>\n    )\n  }\n)\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}